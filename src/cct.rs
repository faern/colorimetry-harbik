/*!
# Calculation of Correlated Color Temperature and Tint

Correlated Color Temperature and Tint are two parameters representing the color
of lamps.
They are related to the color of incandescent lamps, which light is generated by
**thermal emission**.
Any object with a temperature above 0 Kelvin emits
electromagnetic radiation, mainly in the infrared part of the spectrum,
invisible to the human eye.
Only when an object gets very hot, such as a piece of metal heated up to be
shaped by a blacksmith, this radiation starts to become visible.
First, it will be dark red, and the hotter it gets, it will turn more orange,
and ultimately in a yellow-white color.

The spectral distribution of thermal emission of black, non-reflecting objects
is described by **Planck's law**; black objects only, with a _spectral reflectivity_ of zero,
and a _spectrial emissivity_ of one across the spectrum.
Spectral reflectivitity of grey objects is also temperature dependent, especially at high temperatures,
and also depends on the material itself and can not be described by a simple mathematical model.

The chromaticity coordinates of a **blackbody emitter** depend on its temperature
only, and form a curve in a chromaticity diagram, referred to as a blackbody or
**Planckian Locus**.
The chromaticity of gray thermal emitters or non-thermal emitters are typically not
located at this curve and are dependent on more parameters than only
temperature.
But their color can be compared to the color of a purely black thermal emitter:
the temperature of a purely black emitter matching the color of a lamp is called
its **Correlated Color Temperature**, or **CCT**, and its deviation from the Planckian Locus
is sometimes referred to as **Tint**.

Originallly the CIE defined the correlated color temperature for a stimulus as the temperature of a
blackbody emitter with the shortest distance to it in the CIE 1960 (u,v) color space.
This diagram was superseded by the CIE 1976 (u', v') color space but kept using the original metric
by requiring the distance to be calculated by scaling the v' coordinate by a factor of 2/3.
Changing it would have had big implications for the lighting industry, having to deal with old and new
definitions over a long time, effectively changing the definition from a percetption to a purely
mathematical definition.

The CIE standard requires CCT to be calculated using the CIE 1931 standard observer.

*/



use std::sync::OnceLock;

use crate::{physics::planck, CmError, Observer, ObserverTag, CIE1931, NS, XYZ};



const MIRED_MAX: usize = 1000;
const NP:usize = 4096;
fn im2t(im: usize) -> f64 {
    1E6/( 1.0 + ((((MIRED_MAX-1)*im)) as f64) / ((NP-1) as f64)) 
}


pub fn cct(xyz: &XYZ) -> Result<[f64;2], CmError> {
    if xyz.obs_id != ObserverTag::Std1931 { return Err(CmError::RequiresCIE1931XYZ); }
    todo!()
}


/// Table row of Robertson's Iso Correlated Color Temperature lines, with 4096
/// `(u,v)`` (CIE1960) chromaticity coordinates, and Plankian locus slopes `m`.
///
/// These are used for calculating correlated color temperatures from
/// chromaticity coordinates, as implemente in `XYZ`'s cct method.
/// Index 0 corresponds to a color temperature of 1000K, and index 4096 to a
/// temperature of 1_000_00K (see function `im2t``).
/// This table is empty on start-up, and rows get filled each time a table
/// entry is requested.
///
/// For more information, see `The Improved Robertson Method for Calculating
/// Correlated Color Temperature` by Gerard Harbers.
pub fn robertson_4k_table(im: usize) -> [f64;3] {
    static ROBERTSON_TABLE: OnceLock<[OnceLock<[f64;3]>;4096]> = OnceLock::new();

    // Get reference to table, or initialize it when not done yet.
    const EMPTY_ROW: OnceLock<[f64;3]> = OnceLock::new();
    let robertson_table = ROBERTSON_TABLE.get_or_init(|| {
        [EMPTY_ROW; 4096]
    });
    
    // Get table row, or calculate when not done yet.
    let _uvm = robertson_table[im].get_or_init(||{
            let cct = im2t(im);
            let [u,v] = CIE1931.xyz_planckian_locus(cct).uv60();
            let m = CIE1931.planckian_locus_slope(cct);
            [u,v,m]
        }
    );
    todo!()
}
