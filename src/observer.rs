/*!

# Standard Observers

What we perceive as color are sensations in the virtual cortex located in the back of our brain.
These sensations are triggered by stimuli from the photosensitive layer in the back of our eyes, called retina.
Human vision is trichromatic, which means that light, when entering our eyes, is classified by three stimuli.
In colorimetry, at the physiological level, these stimuli are represented by the X, Y, and Z tristimulus values, using the CIE XYZ color model, and using three types of color sensitivity functions, called color matching functions, for an average or standard observer.
At the psychological level, these tristimulus values are used by more advanced color models, such as the CIELAB and CIECAM, to describe the sensations of color in our minds.

## The Retina, and the L, M, and S Cones.
Color models are based on the impulses generated by the retina, particularly its photosensitive cells in humans with normal color vision, which come in three types: the L, M, and S cones.
These letters indicate their spectral sensitivity, which is a measure of how sensitive these cones are to different wavelengths of light. With L indicating the more long-wavelength or red-sensitive cones, M being the more medium or green wavelength-sensitive cone, and S being the short or blue wavelength.
These spectral sensitivities are unique to each individual, and only some have three types of cones, making each person's perception of color truly one-of-a-kind.
For example, some people with abnormal color vision, about 8% of males and 0.5% of women, will see color differently.

The distribution of the different type of cones is not uniform within the retina, with the vision center, the 'Fovea', with an angular extend of about 2ยบ, has the highest density of the three types.
For off-axis vision the cone density drops quickly, while beyond an angle of 10ยบ they disappear, leaving only the rods, used for vision in low light conditions.
The relative amount of L, M, and S cones varies also between different observers, and even between your left and right eyes, due to development conditions in embryotic growth.


## Genetic Basis of Color Vision
Primarily, this is caused by genetic differences.
Genes on the X-chromosome contain the recipe for generating complex molecules called chromophores in our cones.
When these molecules are excited by electromagnetic radiation, they trigger the generation of electrochemical reactions that form a stimulus sent to the virtual cortex in the back of our brain.
There are different variations besides the primary distinction of L, M, and S type of chromophores.
Genes such as an M- or L-type chromophore might be missing, causing red-green color blindness, the most common color deficiency in men.
Women have two types of X-chromosomes; if a gen is missing on one, the other will build them.

## Spectral Sensitivity of the Human Eye
Besides the cones, spectral sensitivity is also influenced by the other parts in our eyes, such as the cornea, lens, the fluid in our eyeballs, and the macula covering the retine, which helps to protect the photosensitive cells to harmfull deep blue and near uv radiation.
It are especially these, which change with age and health, and make that we see colors differently when growing older.

## Color Matching
Scientists have developed visual colorimeters to measure the spectral sensitivity of our eyes.
In these, people, called observers in color science, are asked to match a particular color with a combination of red, green, and blue (RGB) primaries.
Typically, observers look at a disk with an angular extend of 2ยบ, composed of a left and right half, called a "bipartite field".
One half is the test field, the other the match field, consistinng of a mixcure of the three RGB primaries.
The primaries in these visual colorimeters are composed of narrow-band spectral lights, with a wavelength of about 700nm for red, 546nm for green, and 436nm for blue.
The observers' task is to change the relative intensity of the red, green, and blue primaries until they no longer see any difference, and the match values are recorded.
Sometimes, a direct match is impossible, for example, with the more blueish-green colors.
In this case, users might need to add some of the red primary color to the test color to match it and, similarly, some other colors and primaries.
The contribution added to the test field is given a negative value.

## RGB Color Matching Functions
Typically, the test color patch in color matching experiments uses narrow band spectral color too, and is varied to cover a wavelength domain from 360 to 830 nanometer.
The results of an experiment results in a table of red, green, and blue values, which match all these test colors; when plotted as function of wavelength in color science they are referred to as RGB color matching functions.
The first systematic measurements were done with colorimeters developed by David Wright in the US, using 10 observers, including himself, and by John Guild in the UK, using 7 observers, incouding himself.
All the observers were male, and with an age between 20 and 40.

# The CIE 1931 XYZ Color Space
The RGB color matching functions meaasured by Guild and Wright for a total of 17 observers were averaged to define a standard observer.
To avoid using negative values in the RGB color matching functions, a transformation was defined using virtual primaries, resulting in the XYZ color space. and the $\hat(x)(\lambda)$, $\hat(y)(\lambda)$, and $\hat{z}(\lambda)$ color matching functions.
In addition, the $\hat{y}(\lambda)$ function was chosen to be a scaled version of the photopic luminaosity $V(\lambda)$ function, as standardized by the CIE in 1924.




Their monochrome X,Y, and Z values are used to define the perimeter of all the visible
colors in a two-dimensional chromaticity diagram, such as the CIE 1931 (x,y) color space.
In these diagrams, the end points of this perimeter, called spectral locus,
are not uniquly defined by the wavelength paramter anymore.
At these edges, a single chormaticity value can be associated with different wavelengths.
Color matching functions defined by the CIE have a broad wavelength range.

 */

use crate::{
    colorant::Colorant,
    error::CmtError,
    geometry::LineAB,
    lab::CieLab,
    physics::{planck, planck_slope, to_wavelength},
    rgbspace::RgbSpace,
    spectrum::{Spectrum, NS, SPECTRUM_WAVELENGTH_RANGE},
    std_illuminants::StdIlluminant,
    traits::{Filter, Light},
    xyz::XYZ,
};
use nalgebra::{Matrix3, SMatrix, Vector3};
use std::{
    borrow::{Borrow, Cow},
    sync::OnceLock,
};
use wasm_bindgen::{convert::IntoWasmAbi, prelude::wasm_bindgen};

/**
   Light-weight identifier added to the `XYZ` and `RGB` datasets,
   representing the colorimetric standard observer used.

   No data included here, which would be the Rust way, but that does not work with wasm-bindgen.
   This can be directly used in JavaScript, and has the benefit to be just an index.
*/
#[cfg(not(feature = "supplemental-observers"))]
#[wasm_bindgen]
#[derive(Clone, Copy, Default, PartialEq, Eq, Debug)]
pub enum Observer {
    #[default]
    Std1931,
}

#[cfg(feature = "supplemental-observers")]
#[wasm_bindgen]
#[derive(Clone, Copy, Default, PartialEq, Eq, Debug)]
pub enum Observer {
    #[default]
    Std1931,
    Std1964,
    Std2015,
    Std2015_10,
}

impl Observer {
    /**
       Get a reference to the data for the specified `Observer`.
    */
    pub fn data(&self) -> &'static ObserverData {
        match self {
            Observer::Std1931 => &crate::data::observers::CIE1931,
            #[cfg(feature = "supplemental-observers")]
            Observer::Std1964 => &crate::data::observers::CIE1964,
            #[cfg(feature = "supplemental-observers")]
            Observer::Std2015 => &crate::data::observers::CIE2015,
            #[cfg(feature = "supplemental-observers")]
            Observer::Std2015_10 => &crate::data::observers::CIE2015_10,
        }
    }
}

/**
    A data structure to define Standard Observers, such as the CIE 1931 2ยบ and
    the CIE 2015 standard observers.

    These are defined in the form of the three color matching functions,
    typically denoted by $\hat{x}(\lamda)$,$\hat{y}{\lambda}$, and $\hat{z}(\lambda)$.
    Traditionally, the CIE1931 Colorimetric Standard Observer is used almost exclusively,
    but is known to be not a good representation of human vision in the blue region of the
    spectrum. We also know now that the way you see color varies with age, and your healty,
    and that not everyone sees to same color.

    In this library colors are represented by spectral distributions, to allow color modelling
    with newer, and better standard observers, such as the CIE2015 Observer, derived from
    the sensitivities of the cones in the retina of your eye, the biological color receptors
    of light.

    It's main purpose is to calculate `XYZ` tristimulus values for a general stimulus,
    in from of a `Spectrum`.
*/
#[wasm_bindgen]
pub struct ObserverData {
    pub(crate) data: SMatrix<f64, 3, NS>,
    pub(crate) lumconst: f64,
    pub(crate) tag: Observer,
}

impl ObserverData {
    /// Calulates Tristimulus values for an object implementing the [Light] trait, and an optional [Filter],
    /// filtering the light.
    ///
    /// The Light trait is implemented by [`StdIlluminant`] and [Illuminant](crate::illuminant::Illuminant).
    ///
    /// [`Colorant`] implments the [`Filter`] trait.
    /// [`RGB`](crate::rgb::RGB), which represents a display pixel, implements both in this library.
    /// As a light, it is the light emitted from the pixel, as a filter it is the RGB-composite
    /// filter which is applied to the underlying standard illuminant of color space.
    pub fn xyz(&self, light: &dyn Light, filter: Option<&dyn Filter>) -> XYZ {
        // let xyzn = self.xyz_cie_table(illuminant, None);
        let xyzn = light.xyzn(self.tag, None);
        let xyz = if let Some(flt) = filter {
            let s = *light.spectrum() * *flt.spectrum();
            self.xyz_from_spectrum(&s, Some(xyzn))
        } else {
            xyzn
        };
        xyz.set_illuminance(100.0)
    }

    /**
        Calculates Tristimulus valus, in form of an [XYZ] object of a general spectrum.
        If a reference white is given (rhs), it will copy its  tristimulus value, and the spectrum
        is interpreted as a stimulus, being a combination of an illuminant with a colorant.
        If no reference white is given, the spectrum is interpreted as an illuminant.
        This method produces the raw XYZ data, not normalized to 100.0

    */
    pub fn xyz_from_spectrum(&self, spectrum: &Spectrum, rhs: Option<XYZ>) -> XYZ {
        let xyz = self.data * spectrum.0 * self.lumconst;
        if let Some(xyz0) = rhs {
            // A illuminant/colorant
            XYZ::from_vecs(xyz0.xyzn, Some(xyz), self.tag)
        } else {
            // illuminant only
            XYZ::from_vecs(xyz, None, self.tag)
        }
    }

    /**
        Tristimulus Values for the Standard Illuminants in this library.

        Values are calculated on first use, and are not normalized by default, unless an illuminous
        value is provided, in case they are.
    */
    pub fn xyz_cie_table(&self, std_illuminant: &StdIlluminant, illuminance: Option<f64>) -> XYZ {
        const XYZ_STD_ILLUMINANTS_LEN: usize = 64;
        static XYZ_STD_ILLUMINANTS: [OnceLock<XYZ>; XYZ_STD_ILLUMINANTS_LEN] =
            [const { OnceLock::new() }; XYZ_STD_ILLUMINANTS_LEN];

        let xyz = *XYZ_STD_ILLUMINANTS[*std_illuminant as usize]
            .get_or_init(|| self.xyz_from_spectrum(std_illuminant.illuminant(), None));
        if let Some(l) = illuminance {
            xyz.set_illuminance(l)
        } else {
            xyz
        }
    }

    /// XYZ tristimulus values for the CIE standard daylight illuminant D65.
    /// The values are calculated on first use.
    pub fn xyz_d65(&self) -> XYZ {
        self.xyz_cie_table(&StdIlluminant::D65, Some(100.0))
    }

    /// XYZ tristimulus values for the CIE standard daylight illuminant D50.
    /// The values are calculated on first use.
    pub fn xyz_d50(&self) -> XYZ {
        self.xyz_cie_table(&StdIlluminant::D50, Some(100.0))
    }

    /**
        Calculates XYZ tristimulus values for an analytic representation of a spectral distribution of
        a filter or a color patch, using a normalized wavelength domain ranging from a value of 0.0 to 1.0,
        illuminated with a standard illuminant.

        The spectral values should be defined within a range from 0.0 to 1.0, and are clamped otherwise.
        The resulting XYZ value will have relative Y values in the range from 0 to 100.0,
        and yw is set to a value of 100.0.

        # Examples
        Linear high pass filter, with a value of 0.0 for a wavelength of 380nm, and a value of 1.0 for 780nm,
        and converting the resulting value to RGB values.
        ```
            use colorimetry::prelude::*;
            let rgb: [u8;3] = CIE1931.xyz_from_std_illuminant_x_fn(&StdIlluminant::D65, |x|x).rgb(None).into();
            assert_eq!(rgb, [212, 171, 109]);
        ```
        Linear low pass filter, with a value of 1.0 for a wavelength of 380nm, and a value of 0.0 for 780nm,
        and converting the resulting value to RGB values.
        ```
            use colorimetry::prelude::*;
            let rgb: [u8;3] = CIE1931.xyz_from_std_illuminant_x_fn(&StdIlluminant::D65, |x|1.0-x).rgb(None).into();
            assert_eq!(rgb, [158, 202, 237]);
        ```

    */
    pub fn xyz_from_std_illuminant_x_fn(
        &self,
        illuminant: &StdIlluminant,
        f: impl Fn(f64) -> f64,
    ) -> XYZ {
        let s = illuminant.illuminant();
        let xyzn = self.xyz_cie_table(illuminant, None).xyzn;
        let xyz =
            self.data.column_iter().zip(s.0 .0.iter()).enumerate().fold(
                Vector3::zeros(),
                |acc, (i, (cmfi, sv))| {
                    acc + cmfi * f(i as f64 / (NS - 1) as f64).clamp(0.0, 1.0) * *sv
                },
            );
        XYZ {
            xyz: Some(xyz * self.lumconst),
            xyzn,
            observer: self.tag,
        }
        .set_illuminance(100.0)
    }

    /**
        Calculates XYZ tristimulus values for an illuminant with its spectral distribution
        described by a function, defined over a domain from 0.0 to 1.0, with 0.0 corresponding to
        a wavelength of 380nm, and 1.0 to a wavelength of 780nm.

        It is mainly used in this library to calculate the Planckian locus, which is described by
        Planck's law.  The resulting XYZ value will be normalized to hava a Y value of 100.0
        and yw is set to None.
    */
    pub fn xyz_fn_illuminant(&self, f: impl Fn(f64) -> f64) -> XYZ {
        let xyzn = self
            .data
            .column_iter()
            .enumerate()
            .fold(Vector3::zeros(), |acc, (i, cmf)| {
                acc + cmf * f(i as f64 / (NS - 1) as f64)
            });
        XYZ {
            xyz: None,
            xyzn,
            observer: self.tag,
        }
    }

    /// Calculates XYZ tristimulus values for a Planckian emitter for this
    /// observer. The `to_wavelength`` function is used, as planck functions
    /// requires the wavelength to be in units of meters, and the
    /// `xyz_from_illuminant_as_fn` uses functions over a domain from 0.0 to
    /// 1.0.
    pub fn xyz_planckian_locus(&self, cct: f64) -> XYZ {
        self.xyz_fn_illuminant(|l| planck(to_wavelength(l, 0.0, 1.0), cct))
    }

    /// The slope of the Plancking locus as a (dX/dT, dY/dT, dZ/dT) contained in
    /// a XYZ object.
    pub fn xyz_planckian_locus_slope(&self, cct: f64) -> XYZ {
        self.xyz_fn_illuminant(|l| planck_slope(to_wavelength(l, 0.0, 1.0), cct))
    }

    /// Calculates the L*a*b* CIELAB D65 values of a Colorant, using D65 as an illuminant.
    /// Accepts a Colorant Spectrum only.
    /// Returns f64::NAN's otherwise.
    pub fn lab_d65(&self, filter: &dyn Filter) -> CieLab {
        let xyz0 = self.xyz(&StdIlluminant::D65, Some(filter));
        xyz0.try_into().unwrap()
    }

    /// Calculates the L*a*b* CIELAB D50 values of a Colorant, using D65 as an illuminant.
    /// Accepts a Colorant Spectrum only.
    /// Returns f64::NAN's otherwise.
    pub fn lab_d50(&self, filter: &dyn Filter) -> CieLab {
        let xyz0 = self.xyz(&StdIlluminant::D50, Some(filter));
        xyz0.try_into().unwrap()
    }

    /// Calculate the Spectral Locus, or (x,y) coordinates of the _horse shoe_,
    /// the boundary of area of all physical colors in a chromiticity diagram,
    /// as XYZ tristimulus values.  Tristimulus values are returned here,
    /// instead of chromaticity xy coordinates, to make use of the available XYZ
    /// transforms.
    ///
    /// This function limits the input values to produce unique chromaticity
    /// values only.  Spectral locus points tend to freeze, or even fold back to
    /// lower wavelength values at the blue and red perimeter ends.  This can be
    /// quite anoying, for example when trying to calculate dominant wavelength,
    /// or when creating plots.  To get the allowed range, use the
    /// `spectral_wavelength_min` and `spectral_wavelength_max` methods.
    ///
    /// See Wikipedia's [CIE 1931 Color Space](https://en.wikipedia.org/wiki/CIE_1931_color_space).
    pub fn spectral_locus_by_nm(&self, l: usize) -> Result<XYZ, CmtError> {
        let min = self.spectral_locus_nm_min();
        let max = self.spectral_locus_nm_max();
        if !SPECTRUM_WAVELENGTH_RANGE.contains(&l) {
            return Err(CmtError::WavelengthOutOfRange);
        };
        if l < min || l > max {
            Err(CmtError::NoUniqueSpectralLocus(min, max))
        } else {
            let &[x, y, z] = self.data.column(l - 380).as_ref();
            Ok(XYZ::from_vecs(Vector3::new(x, y, z), None, self.tag))
        }
    }

    /// Unrestricted, direct, access to the spectal locus data.
    /// To get unique values only please use the `spectral_locus_by_nm` function.
    pub fn spectral_locus_by_index(&self, i: usize) -> [f64; 2] {
        let &[x, y, z] = self.data.column(i).as_ref();
        let s = x + y + z;
        [x / s, y / s]
    }

    /// The index value of the blue spectral locus edge.
    ///
    /// Any further spectral locus points will hover around this edge, and will not have a unique wavelength.
    pub fn spectral_locus_index_min(&self) -> usize {
        static MIN: OnceLock<usize> = OnceLock::new();
        *MIN.get_or_init(|| {
            const START: usize = 100;
            let mut lp =
                LineAB::try_new(self.spectral_locus_by_index(START), [0.33333, 0.33333]).unwrap();
            let mut m = START - 1;
            loop {
                let l =
                    LineAB::try_new(self.spectral_locus_by_index(m), [0.33333, 0.33333]).unwrap();
                match (m, l.angle_diff(lp)) {
                    (0, d) if d > -f64::EPSILON => break m + 1,
                    (0, _) => break 0,
                    (1.., d) if d > -f64::EPSILON => break m,
                    _ => {
                        m -= 1;
                        lp = l;
                    }
                }
            }
        })
    }

    pub fn spectral_locus_nm_min(&self) -> usize {
        self.spectral_locus_index_min() + 380
    }

    /// The index value of the red spectral locus edge.
    ///
    /// Any further spectral locus points will hover around this edge.
    pub fn spectral_locus_index_max(&self) -> usize {
        static MAX: OnceLock<usize> = OnceLock::new();
        *MAX.get_or_init(|| {
            const START: usize = 300;
            let mut lp =
                LineAB::try_new(self.spectral_locus_by_index(START), [0.33333, 0.33333]).unwrap();
            let mut m = START + 1;
            loop {
                let l =
                    LineAB::try_new(self.spectral_locus_by_index(m), [0.33333, 0.33333]).unwrap();
                match (m, l.angle_diff(lp)) {
                    (400, d) if d < f64::EPSILON => break m - 1,
                    (400, _) => break 400,
                    (..400, d) if d < f64::EPSILON => break m - 1,
                    _ => {
                        m += 1;
                        lp = l;
                    }
                }
            }
        })
    }

    pub fn spectral_locus_nm_max(&self) -> usize {
        self.spectral_locus_index_max() + 380
    }

    /// Calculates the RGB to XYZ matrix, for a particular color space.
    /// The matrices are buffered.
    pub fn rgb2xyz(&self, rgbspace: &RgbSpace) -> &'static Matrix3<f64> {
        const RGB2XYZ_AR_LEN: usize = 16;
        static RGB2XYZ_AR: [OnceLock<Matrix3<f64>>; RGB2XYZ_AR_LEN] =
            [const { OnceLock::new() }; RGB2XYZ_AR_LEN];

        RGB2XYZ_AR[*rgbspace as usize].get_or_init(|| {
            let (space, _) = rgbspace.data();
            let mut rgb2xyz = Matrix3::from_iterator(space.primaries.iter().flat_map(|s| {
                self.xyz_from_spectrum(s, None)
                    .set_illuminance(1.0)
                    .values()
            }));
            // let xyzw = self.xyz_raw(&space.white, None).set_illuminance(1.0);
            let xyzw = self.xyz(&space.white, None).set_illuminance(1.0);
            let decomp = rgb2xyz.lu();
            // unwrap: only used with library color spaces
            let rgbw = decomp.solve(&xyzw.xyzn).unwrap();
            for (i, mut col) in rgb2xyz.column_iter_mut().enumerate() {
                col *= rgbw[i];
            }
            rgb2xyz
        })
    }

    /// Calculates the RGB to XYZ matrix, for a particular color space.
    /// The matrices are buffered.
    pub fn xyz2rgb(&self, rgbspace: RgbSpace) -> &'static Matrix3<f64> {
        const XYZ2RGB_AR_LEN: usize = 16;
        static XYZ2RGB: [OnceLock<Matrix3<f64>>; XYZ2RGB_AR_LEN] =
            [const { OnceLock::new() }; XYZ2RGB_AR_LEN];
        XYZ2RGB[rgbspace as usize].get_or_init(|| {
            // unwrap: only used with library color spaces
            self.rgb2xyz(&rgbspace).try_inverse().unwrap()
        })
    }
}

// JS-WASM Interface code
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
impl ObserverData {}

#[cfg(test)]
mod obs_test {

    use crate::prelude::{StdIlluminant, CIE1931};
    use approx::assert_ulps_eq;

    #[test]
    fn test_spectral_locus() {
        let [x, y] = CIE1931
            .spectral_locus_by_nm(CIE1931.spectral_locus_nm_min())
            .unwrap()
            .chromaticity();
        assert_ulps_eq!(x, 0.17411, epsilon = 1E-5);
        assert_ulps_eq!(y, 0.00496, epsilon = 1E-5);

        let [x, y] = CIE1931
            .spectral_locus_by_nm(CIE1931.spectral_locus_nm_max())
            .unwrap()
            .chromaticity();
        assert_ulps_eq!(x, 0.73469, epsilon = 1E-5);
        assert_ulps_eq!(y, 0.26531, epsilon = 1E-5);
    }

    #[test]
    fn test_spectral_locus_min_max() {
        let min = CIE1931.spectral_locus_index_min();
        println!("{min}");
        let max = CIE1931.spectral_locus_index_max();
        println!("{max}");
    }

    #[test]
    // Data from http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
    // Lindbloom's values are reproduced with an accuracy of 3E-4, which is
    // a small, but significant difference.  This difference is caused by a difference in the display's white point,
    // due to wavelength domain differences.  Here we use a domain
    // from 380 to 780 with a step of 1 nanometer for the spectra, and in
    // specific for the color matching functions, as recommended by
    // CIE15:2004, and the color matching functions provided by the CIE in
    // their online dataset section. The spectra for the primaries are chosen to match the RGB primary values as given by the Color Space specifications.
    // The white point uses the standard's spectral distribution, as provided by the CIE, clipped to a domain from 380 to 780 nanometer.
    // See `colorimetry::data::D65`.
    fn test_rgb2xyz_cie1931() {
        let want = nalgebra::Matrix3::new(
            0.4124564, 0.3575761, 0.1804375, 0.2126729, 0.7151522, 0.0721750, 0.0193339, 0.1191920,
            0.9503041,
        );
        let got = CIE1931.rgb2xyz(&crate::rgbspace::RgbSpace::SRGB);
        approx::assert_ulps_eq!(want, got, epsilon = 3E-4);
    }

    #[test]
    // Check the inverse transformation.
    // See comments at `test_rgb2xyz_cie1931`.
    fn test_xyz2rgb_cie1931() {
        let want = nalgebra::Matrix3::new(
            3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434,
            -0.2040259, 1.0572252,
        );
        let got = CIE1931.xyz2rgb(crate::rgbspace::RgbSpace::SRGB);
        approx::assert_ulps_eq!(want, got, epsilon = 3E-4);
    }

    #[test]
    fn test_xyz_std_illuminants() {
        use crate::xyz::XYZ;
        use nalgebra as na;
        let XYZ {
            xyz,
            xyzn,
            observer,
        } = CIE1931.xyz_cie_table(&StdIlluminant::D65, Some(100.0));
        approx::assert_ulps_eq!(xyzn, na::Vector3::new(95.04, 100.0, 108.86), epsilon = 1E-2);
        assert!(xyz.is_none());
    }

    #[test]
    fn test_planckian_locus() {
        // see https://www.waveformlighting.com/tech/calculate-cie-1931-xy-coordinates-from-cct
        // for test data (not clear what CMF domain they use)
        let xy = CIE1931.xyz_planckian_locus(3000.0).chromaticity();
        approx::assert_abs_diff_eq!(&xy.as_ref(), &[0.43693, 0.40407].as_ref(), epsilon = 2E-5);

        let xy = CIE1931.xyz_planckian_locus(6500.0).chromaticity();
        approx::assert_abs_diff_eq!(&xy.as_ref(), &[0.31352, 0.32363].as_ref(), epsilon = 6E-5);
    }

    #[test]
    fn test_xyz_from_illuminant_x_fn() {
        let xyz = CIE1931.xyz_from_std_illuminant_x_fn(&StdIlluminant::D65, |_v| 1.0);
        let d65xyz = CIE1931.xyz_d65().xyzn;
        approx::assert_ulps_eq!(
            xyz,
            crate::xyz::XYZ::from_vecs(d65xyz, Some(d65xyz), crate::observer::Observer::Std1931)
        );
    }

    #[test]
    fn test_xyz_of_sample_with_standard_illuminant() {
        use crate::prelude::{StdIlluminant::D65 as d65, XYZ};
        let xyz = CIE1931.xyz(&d65, Some(&crate::colorant::Colorant::white()));
        approx::assert_ulps_eq!(xyz, CIE1931.xyz_from_std_illuminant_x_fn(&d65, |_| 1.0));

        let xyz = CIE1931.xyz(&d65, Some(&crate::colorant::Colorant::black()));
        approx::assert_ulps_eq!(xyz, CIE1931.xyz_from_std_illuminant_x_fn(&d65, |_| 0.0));
    }
}
